-- Serviços
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local selectedPlayerName = nil

-- Carregar Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/tiololo487/Script/refs/heads/main/library"))()

workspace.FallenPartsDestroyHeight = -math.huge

-- Criar Janela
local Window = Library:MakeWindow({
    Title = "anonymus Hub | Brookhaven",
    SubTitle = "By: silvadev",
    LoadText = "Carregando anonymus Hub...",
    Flags = "anonymushub_Brookhaven",
    Size = UDim2.fromScale(0.55, 0.65)
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://2483186", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(35, 1) },
})

-- Criar Tab
local Troll = Window:MakeTab({
    Title = "| Troll",
    Icon = "rbxassetid://15309138473"
})

------------------------------------------------------------------
-- Função para pegar lista de jogadores
------------------------------------------------------------------

local function getPlayerList()
    local playerNames = {}

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end

    return playerNames
end

------------------------------------------------------------------
-- Dropdown de jogadores
------------------------------------------------------------------

local playerDropdown = Troll:AddDropdown({
    Name = "Select Player",
    Options = getPlayerList(),
    Default = "",
    Callback = function(value)
        selectedPlayerName = value
        print("Selected player:", value)
    end
})

------------------------------------------------------------------
-- Botão atualizar lista
------------------------------------------------------------------

Troll:AddButton({
    Name = "Refresh Player List",
    Callback = function()
        local newList = getPlayerList()
        playerDropdown:Set(newList)

        if selectedPlayerName and not Players:FindFirstChild(selectedPlayerName) then
            selectedPlayerName = nil
            playerDropdown:SetValue("")
        end
    end
})

-- Fling Ball Melhorado 2026 - Mobile Friendly (Delta/Arceus X/iOS)
local function FlingBallImproved(targetPlayer)
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")
    local hum = char:WaitForChild("Humanoid")
    local backpack = player:WaitForChild("Backpack")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    
    local ServerBallsFolder = workspace:WaitForChild("WorkspaceCom", 8):WaitForChild("001_SoccerBalls", 8)
    if not ServerBallsFolder then
        warn("Pasta de bolas não encontrada!")
        return
    end
    
    local ballName = "Soccer" .. player.Name
    local Ball = ServerBallsFolder:FindFirstChild(ballName)
    
    -- Função pra pegar/criar a bola se não tiver
    local function GetOrCreateBall()
        if not backpack:FindFirstChild("SoccerBall") then
            local pickEvent = ReplicatedStorage.RE:FindFirstChild("1Too1l")
            if pickEvent then
                pickEvent:InvokeServer("PickingTools", "SoccerBall")
            end
        end
        
        task.wait(0.4)  -- Espera sync
        if backpack:FindFirstChild("SoccerBall") then
            backpack.SoccerBall.Parent = char
            task.wait(0.4)
            backpack.SoccerBall.Parent = backpack  -- Sync server
        end
        
        Ball = ServerBallsFolder:WaitForChild(ballName, 5)
        return Ball
    end
    
    if not Ball then
        Ball = GetOrCreateBall()
    end
    if not Ball then
        warn("Bola não encontrada após tentativa!")
        return
    end
    
    -- Config física da bola (massless + low density pra fling forte)
    Ball.CanCollide = false
    Ball.Massless = true
    Ball.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0, 0.5, 0.5, 1)  -- Ajustado pra menos bounce
    
    if targetPlayer == player or not targetPlayer.Character then return end
    
    local targetChar = targetPlayer.Character
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    local targetHum = targetChar:FindFirstChild("Humanoid")
    
    if not targetRoot or not targetHum or targetHum.Health <= 0 then return end
    
    -- Limpa movers antigos
    for _, child in Ball:GetChildren() do
        if child:IsA("BodyMover") or child:IsA("AlignPosition") or child:IsA("AlignOrientation") then
            child:Destroy()
        end
    end
    
    -- Cria AlignPosition + AlignOrientation (mais suave que BodyVelocity em 2026)
    local alignPos = Instance.new("AlignPosition")
    alignPos.Name = "FlingAlign"
    alignPos.MaxForce = math.huge
    alignPos.Responsiveness = 200  -- Alto pra seguir rápido
    alignPos.RigidityEnabled = false  -- Suave
    alignPos.Parent = Ball
    
    local alignOri = Instance.new("AlignOrientation")
    alignOri.Name = "FlingOri"
    alignOri.MaxTorque = math.huge
    alignOri.Responsiveness = 150
    alignOri.Parent = Ball
    
    -- BodyVelocity fallback (pra boost extra)
    local bv = Instance.new("BodyVelocity")
    bv.Name = "FlingBoost"
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.new(0, 0, 0)  -- Vamos atualizar dinamicamente
    bv.Parent = Ball
    
    -- Camera pra ver o caos (opcional, mas ajuda no troll)
    workspace.CurrentCamera.CameraSubject = targetHum
    
    local startTick = tick()
    local connection
    
    connection = RunService.Heartbeat:Connect(function(deltaTime)
        if not Ball or not Ball.Parent or not targetRoot or not targetRoot.Parent or targetHum.Health <= 0 or tick() - startTick > 12 then
            connection:Disconnect()
            workspace.CurrentCamera.CameraSubject = hum
            if alignPos then alignPos:Destroy() end
            if alignOri then alignOri:Destroy() end
            if bv then bv:Destroy() end
            return
        end
        
        -- Previsão melhor: velocity + extrapolação (considera lag \~0.1-0.2s)
        local targetVel = targetRoot.AssemblyLinearVelocity
        local predictionOffset = targetVel * 0.15  -- Ajuste aqui (0.1 = baixo ping, 0.25 = alto ping)
        
        local predictedPos = targetRoot.Position + predictionOffset + Vector3.new(0, 2, 0)  -- Um pouco acima pra bater no torso
        
        -- Se parado, tenta mirar em qualquer parte do corpo
        if targetVel.Magnitude < 5 then
            local closestPart = nil
            local minDist = math.huge
            for _, part in targetChar:GetChildren() do
                if part:IsA("BasePart") and part.CanCollide and not part.Anchored then
                    local dist = (part.Position - Ball.Position).Magnitude
                    if dist < minDist then
                        minDist = dist
                        closestPart = part
                    end
                end
            end
            if closestPart then
                predictedPos = closestPart.Position
            end
        end
        
        -- Aplica
        alignPos.Position = predictedPos
        alignOri.CFrame = targetRoot.CFrame  -- Mantém orientação similar pra spin legal
        
        -- Boost velocity extra (pra fling insano)
        local directionToTarget = (predictedPos - Ball.Position).Unit
        bv.Velocity = directionToTarget * 250 + Vector3.new(0, 80, 0)  -- Ajuste 250 pra mais/menos força
        
        -- Spin visual
        Ball.AssemblyAngularVelocity = Vector3.new( math.random(-200,200), math.random(-200,200), math.random(-200,200) )
        
        -- Check se já flinged (velocity alta = sucesso)
        if targetRoot.AssemblyLinearVelocity.Magnitude > 500 then
            task.delay(0.5, function()
                connection:Disconnect()
                workspace.CurrentCamera.CameraSubject = hum
                if alignPos then alignPos:Destroy() end
                if alignOri then alignOri:Destroy() end
                if bv then bv:Destroy() end
            end)
        end
    end)
end

-- Exemplo de uso no botão (adicione no seu hub com Kavo ou similar)
-- Troll:AddButton({
--     Name = "Fling Ball Melhorado",
--     Callback = function()
--         local target = game.Players:FindFirstChild(selectedPlayerName)
--         if target then FlingBallImproved(target) end
--     end
-- })

local nukeFlashEnabled = false
local nukeFlashTrack = nil
local flashRigidTrack = nil
local savedNukeFlashBody = {}
local spinConnection = nil

local function stopFlashAnimations()
    if flashRigidTrack then
        pcall(function()
            flashRigidTrack:Stop()
            flashRigidTrack:Destroy()
        end)
        flashRigidTrack = nil
    end
    
    if nukeFlashTrack then
        pcall(function()
            nukeFlashTrack:Stop()
            nukeFlashTrack:Destroy()
        end)
        nukeFlashTrack = nil
    end
end

local function startSpin()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    spinConnection = RunService.RenderStepped:Connect(function(dt)
        hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(460 * dt), 0)
    end)
end

local function stopSpin()
    if spinConnection then
        spinConnection:Disconnect()
        spinConnection = nil
    end
end

Troll:AddToggle({
    Name = "Nuke FlashBack",
    Default = false,
    Callback = function(value)
        nukeFlashEnabled = value
        
        if value then
            startSpin()

            local player = game.Players.LocalPlayer
            local character = player.Character
            
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local description = humanoid:GetAppliedDescription()
                    
                    savedNukeFlashBody = {
                        Torso = description.Torso,
                        RightArm = description.RightArm,
                        LeftArm = description.LeftArm,
                        RightLeg = description.RightLeg,
                        LeftLeg = description.LeftLeg,
                        Head = description.Head
                    }
                    
                    task.wait(0.2)
                    
                    local args = {
                        [1] = 123402086843885,
                        [2] = 100839513065432,
                        [3] = 78300682916056,
                        [4] = 86276701020724,
                        [5] = 78409653958165,
                        [6] = 15093053680
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage").Remotes.ChangeCharacterBody:InvokeServer(args)
                    end)
                    
                    task.wait(0.3)
                    
                    local newAnim = Instance.new("Animation")
                    newAnim.AnimationId = "rbxassetid://70883871260184"
                    
                    nukeFlashTrack = humanoid:LoadAnimation(newAnim)
                    nukeFlashTrack.Priority = Enum.AnimationPriority.Action4
                    nukeFlashTrack:Play(0.1, 1, 1)
                    
                    task.wait(0.1)
                    nukeFlashTrack:AdjustSpeed(5)
                    
                    task.wait(0.3)
                    
                    local plankAnim = Instance.new("Animation")
                    plankAnim.AnimationId = "rbxassetid://3695333486"
                    flashRigidTrack = humanoid:LoadAnimation(plankAnim)
                    flashRigidTrack.Priority = Enum.AnimationPriority.Movement
                    flashRigidTrack:Play(0.1, 1, 0)
                end
            end
        else
            stopSpin()
            stopFlashAnimations()
            
            task.wait(0.2)
            
            if next(savedNukeFlashBody) then
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if character then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local restoreBody = {
                            [1] = savedNukeFlashBody.Torso,
                            [2] = savedNukeFlashBody.RightArm,
                            [3] = savedNukeFlashBody.LeftArm,
                            [4] = savedNukeFlashBody.RightLeg,
                            [5] = savedNukeFlashBody.LeftLeg,
                            [6] = savedNukeFlashBody.Head
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage").Remotes.ChangeCharacterBody:InvokeServer(restoreBody)
                        end)
                        
                        savedNukeFlashBody = {}
                    end
                end
            end
        end
    end
})

